# 常见工具原理以及使用

## 1、全局唯一ID生成
> 常见算法，UUID，tweet snowflake算法

- A、UUID
> `uuid`是32位字符串，全局唯一，随机生成


- B、`tweet snowflake` 64位整数

     
     41位时间戳 + 10位节点ID + 12位序列号
![snowflake标准实现](./snowflake-easy.png)



## 2、`trie字典树`过滤敏感词
> 又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。
典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
它的优点是：`利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。`


![trie树](./trie.png)


-  A：特性
   
   
     1、根节点root不包含数据节点，不包含字符
     2、从根节点开始到某一个结束的节点，中间的节点连接起来构成一个字符串
     3、每个节点的子节点包含的字符都不相同


显然面对大量文本和大量敏感词，利用字典树过滤敏感词是明智而有效的，可以大量的减少重复的抖动，从而降低时间复杂度


- B：算法逻辑

 
     插入节点逻辑：
     1、首先构造根节点，每个节点可能拥有多个子节点
     2、插入字符串时，先按字符切割，从根节点开始寻找要插入的位置
     3、如果是第一次插入，那么新建节点Node，否则继续往下查找
     4、直到插入到最后一个字符时，标识该字符为结尾字符
     
     查找逻辑：
     1、先载入词库，构成字典树
     2、切割要替换的字符串为字符数组
     3、遍历字符数组
     4、从根节点开始查找，如果查找到节点，则继续往下查找；无则重置节点，继续从根节点查找
     
 ```go

//构造trie字典树：减少时间复杂度
package util

type Node struct {
	char   rune           //当前节点对应的字符
	childs map[rune]*Node //当前节点的所有子节点，map存放： 下一个节点--》节点对象,map必须要先初始化才可以使用
	depth  int            //节点深度
	isEnd  bool           //是否结尾词
}
//trie字典树定义
type Trie struct {
	root *Node //根节点
	size int //长度
}

//创建新的字典树
func NewTrie() *Trie {
	return &Trie{
		root: NewNode(),
	}
}

//创建新节点
func NewNode() *Node {
	return &Node{
		childs: make(map[rune]*Node, 32),
	}
}

//将字符串添加到字典树中
func (t *Trie) Add(key string) {
	runeArr := []rune(key)
	node := t.root
	for index, char := range runeArr {
		ret, exists := node.childs[char]
		//不存在则新增
		if !exists {
			ret = NewNode()
			ret.depth = index + 1
			ret.char = char
			node.childs[char] = ret
		}
		node = ret
	}
	node.isEnd = true
	return
}

//查找需要过滤的字符串，并进行替换:从根节点开始查找
func (t *Trie) FilterWords(words, replace string) (result string) {
	wordsRunes := []rune(words)
	node := t.root
	if node == nil {
		return
	}
	//resultRune := make([]rune, len(wordsRunes))
	resultRune := []rune{}
	start := 0
	for index, char := range wordsRunes {
		ret, exists := node.childs[char]
		//如果不存在的话，则保存中间结果,不需要过滤
		if !exists {
			resultRune = append(resultRune, wordsRunes[start:index+1]...)
			start = index + 1
			node = t.root
			continue
		}
		//存在的话
		node = ret
		if node.isEnd {
			node = t.root
			resultRune = append(resultRune, ([]rune(replace))...)
			start = index + 1
			continue
		}
	}
	return string(resultRune)
}
```    

## 3、`etcd`高可用强一致性分布式key-value存储
> go语言开发的分布式存储，主要用来做配置共享和服务发现，类似`consul`和`zookeeper`

 - A：特点：
      
      
      1、配置共享和服务发现
      2、强一致性、分布式存储（zookeeper、consul）
      3、提供http接口，使用简单
      4、基于raft算法实现强一致性、高可以用的服务存储目录
      
 - B：应用场景：
      
      
      1、服务发现和服务注册
      2、配置中心
      3、分布式锁
      4、master选举
    
 - C：搭建
 > go语言编写，直接下载二进制文件即可
     
     下载地址：https://github.com/etcd-io/etcd/releases
      
 
 - D：客户端：
> put：更新一个值
watch：阻塞监听key的变化 
       
       go get go.etcd.io/etcd/clientv3

https://github.com/etcd-io/etcd/tree/master/clientv3
```go

//创建客户端
cli, err := clientv3.New(clientv3.Config{
	Endpoints:   []string{"localhost:2379", "localhost:22379", "localhost:32379"},
	DialTimeout: 5 * time.Second,
})
if err != nil {
	// handle error!
}
defer cli.Close()
```       
       
## 4、`ElasticSearch`分布式搜索引擎

## 5、`kafka`消息队列
> `kafka`是java开发的一个重量级的消息队列。可以异步处理非关键逻辑，提高系统健壮性和响应时间；系统解耦；流量削峰。消息队列还有NSQ、rabbitmq等。

     应用场景：
       1、异步处理非关键逻辑
       2、引用解耦
       3、流量削峰（秒杀系统）实现流量控制，过载保护
       
     安装：
     
       
       
## 6、`zookeeper`


     应用场景：
       1、服务注册和服务发现
          注册中心：保存服务信息
          服务提供者：启动时注册服务信息
          服务消费者：监听服务提供者信息，调用服务提供者
          
       2、注册中心
       
       3、分布式锁（类似etcd和redis的分布式锁）
              

