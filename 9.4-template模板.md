# 9.4、template模板
> 模板渲染 `text/template`或者`html/template`

## 1、解析文件模板
     
       t := template.ParseFiles("文件路径") //解析文件
       t := template.Must(t) //解析文件语法
       (t *Template) Execute(wr io.Writer, data interface{}) error//往响应流写入数据

## 2、解析字符串模板
       t := template.New(name string) //生成一个template对象
       (t *Template) Parse(text string) (*Template, error) //解析字符串
       t := template.Must(t) //判断文件语法是否正确

       var strTempl = template.Must(template.New("TName").Parse(strTemplateHTML))
   
     
## 3、模板中字段替换`{{.FieldName}}`（只有被导出的数据项才可以整合进模板中）
> 模板语法分隔符:`{{}}`，被 `{{}}` 包裹的称之为管道
- a、假如`FieldName`为结构体字段或者map中的key，都可以使用 `.`用法
- b、可以使用管道方式过滤输出到浏览器 `{{.FieldName | html}}`
- c、如果只是想简单地把 `Execute() `方法的第二个参数用于替换，使用` {{.}}`,`{{.}}` 被设置为当前管道的值
- d、`if-else`：条件判断 

       {{if 条件判断}}{{end}}
       {{if 条件判断}}{{else}}{{end}}
       
       //例子: 管道为空
       {{if ``}}Empty{{}}
       {{if `anything`}}anything{{else}}nothing{{end}}

- e、`with-end`：
- f、模板变量`$`：可以在模板内为管道设置本地变量，变量名以 $ 符号作为前缀 ；即在模板内定义变量，需要使用$开头
- g、`range-end`：格式为`{{range pipeline}} T1 {{else}} T0 {{end}}`  

          模板：遍历当前管道（管道的值必须是数组、切片或 map），里面为新的管道，
          {{range .}} 
          {{.}} 
          {{end}}
          
          s := []int{1,2,3,4}
          t.Execute(os.Stdout, s)
          
          输出：
          1
          2
          3
          4
          
- h、模板预定义函数如`printf`类似fmt.Printf

            
          {{ printf "%s" .Body|html}}