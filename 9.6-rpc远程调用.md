# 9.6、rpc远程调用
> `rpc远程调用`在微服务调用非常有用，经常会用到。使用`net/rpc`包完成，通信数据格式为`gob`，实现了自动编码/解码传输的跨网络方法调用。
rpc包使用了tcp和http协议以及用于数据传输的 gob 包。

## 1、定义一个服务
>一个功能可以视为一个服务，例如实现一个加法计算的服务

```go
package cal
import "errors"
//定义一个cal服务  func (t *T) MethodName(argType T1, replyType *T2) error
type Cal struct {
	N1 int
	N2 int
}

//乘法
func (c *Cal) Multi(ca *Cal, reply *int) error {
	*reply = ca.N1 * ca.N2
	return nil
}

//除法
func (c *Cal) Div(ca *Cal, reply *int) error {
	if ca.N2 == 0 {
		return errors.New("error")
	}
	*reply = ca.N1 / ca.N2
	return nil
}
```     

## 2、实现`rpc`服务端
>服务端需要先调用`rpc.Register(service)`将服务注册（也可以用名称来注册服务，如`rpc.RegisterName("Calculator", calc)`），然后再调用`rpc.HandleHTTP()`监听http,
再者使用`net.Listen` 在指定的地址上启动监听。 最后使用`http.Serve(listener, nil)`启动服务器。

    远程调用的方法必须如下定义：
       1、 只有两个参数，第二个参数必须是指针，且是返回内容
       2、 方法、接收者类型必须可以导出
       3、返回值必须是一个error类型
    func (t *T) MethodName(argType T1, replyType *T2) error
    
```go

func main() {
	cal := new(Cal)          //必须是指针
	err := rpc.Register(cal) //注册服务
	//rpc.RegisterName("cal",cal)//使用名称注册服务
	if err != nil {
		fmt.Print("register service error:", err)
		return
	}
	rpc.HandleHTTP() //处理http请求
	listen, err := net.Listen("tcp", ":8081")
	if err != nil {
		fmt.Print("listen tcp server error:", err)
		return
	}
	go http.Serve(listen, nil) //会为每一个进入 listener 的 HTTP 连接创建新的服务线程
	time.Sleep(time.Second * 30)
}
```
  
## 3、实现`rpc`客户端
> 客户端必须知晓对象类型及其方法的定义。执行 `rpc.DialHTTP()` 连接到服务器后，就可以用 `client.Call("Type.Method", args, &reply)` 同步调用远程对象的方法。
`Type` 是远程对象的类型名，`Method` 是要调用的方法，`args` 是方法的第一个参数，`reply` 是方法的第二个参数，是一个必须事先声明的变量，方法调用产生的结果将存入其中。
使用`client.Go("Type.Method",args,&replay,nil)`异步调用。


```go
func main() {
	client, err := rpc.DialHTTP("tcp", "127.0.0.1:8081")
	if err != nil {
		log.Fatal("Error dialing:", err)
	}
	//同步调用
	var reply int
	cal := &Cal{5, 6}
	err = client.Call("Cal.Multi", cal, &reply)
	if err != nil {
		log.Fatal("Args error:", err)
	}
	fmt.Printf("Args: %d * %d = %d\n", cal.N1, cal.N2, reply)
}
```