# Go函数
> 函数：有输入输出，用来执行一个指定任务的代码块。封装公共代码，可以在其他地方调用，减少重复性代码；go中函数也是一种类型，叫做函数类型。
## 1、函数定义
> go中使用`func`关键字来定义函数
     
     func 函数名(形参列表) (返回列表) {
       函数体
     }

## 2、无参无返回值
>无参无返回值函数是最简单的函数定义方式

     func 函数名(){
     
     }

```go
package main
import "fmt"

func main(){
	test()
}

func test()  {
   fmt.Println("test func.")
}
```
## 3、单一返回值(函数体必须要有`return`)
> 返回值列表可以直接写明一个返回类型即可；或者使用括号( 返回值 返回值类型)

    func 函数名(形参1 类型1,形参2 类型2...) (返回变量 返回值类型){
    
    } 
    
    func 函数名(形参1 类型1,形参2 类型2...) 返回值类型{
       return   
    } 
    
```go
//单一返回值
func testSingleReturnV1() int {
	return 1
}

//单一返回值
func testSingleReturnV2() (a int) {
	a = 1
	return
}

```    

## 4、多返回值（函数体必须要有`return`），需要用`()`        
> 多返回值函数返回格式： (返回值类型1，返回值类型2...) 或  (返回值1 返回值类型1，返回值2 返回值类型2...)
；如果返回值类型和后面的返回值类型相同，则类型可省略不写(返回值1,返回值2 返回值类型2...)

     func 函数名() (返回值类型1，返回值类型2...){
     }   
     
     func 函数名() (返回值1 返回值类型1，返回值2 返回值类型2...){
     
     }  

```go
//多返回值
func testMultiReturnV1(a, b int) (int, int) {
	return a + b, a - b
}
func testMultiReturnV2(a, b int) (sum int, sub int) {
	sum = a + b
	sub = a - b
	return
}
func testMultiReturnV3(a, b int) (sum, sub int) { //返回值如果和后面的返回类型相同则类型可省略不写
	sum = a + b
	sub = a - b
	return
}
```  

## 5、可变参数
>传入的参数可以不确定，格式：`args ...type`，`args`为形参名，`type`为数据类型，如int，string,在函数中`args`是一个`type类型`的切片
        
        func 函数名( args ...type){
        
        }  
```go

//可变参数
func testChangeableParam(args ...int) {
	fmt.Printf("%T", args) // []int int类型的切片
	fmt.Println(args)
}
```

## 6、函数类型
> 函数也是一种类型，可以赋值给变量;也可以作为参数传递给函数

     func test(){
       fmt.Println("etest")
     }
     
     func main(){
        a := test
        a()
     }
     
     type FuncType func(int,int)int
     
```go
package main //必须

import "fmt"

func Add(a, b int) int {
	return a + b
}

func Minus(a, b int) int {
	return a - b
}

//函数也是一种数据类型， 通过type给一个函数类型起名
//FuncType它是一个函数类型
type FuncType func(int, int) int //没有函数名字，没有{}

func main() {
	var result int
	result = Add(1, 1) //传统调用方式
	fmt.Println("result = ", result)

	//声明一个函数类型的变量，变量名叫fTest
	var fTest FuncType
	fTest = Add            //是变量就可以赋值
	result = fTest(10, 20) //等价于Add(10, 20)
	fmt.Println("result2 = ", result)

	fTest = Minus
	result = fTest(10, 5) //等价于Minus(10, 5)
	fmt.Println("result3 = ", result)
	
	//
	cal(1,2,Add)
	cal(1,2,Minus)
}

//函数作为参数传递
func cal(a,b int, op FuncType) int{
	return op(a,b)
}
//多形参列表 左边的参数如没写明类型，则类型继承下一个最近的有声明类型的形参
func testMultiParamV2(a, b string) string {
	return a + b
}
func testFuncType() {
	a := testMultiParamV2
	fmt.Println(a("a", "b"))
}
```
## 7、匿名函数
> 匿名函数：即没有名字的函数
```go
func main(){
	a := func(){
		fmt.Println("Ni ming")
	}
	a()//Ni ming
}
```


## 8、`defer`使用
> 延迟调用，函数中使用，`在函数任意位置执行 return 语句之后调用`；defer后面跟函数调用或者匿名函数调用


      1、defer延时调用，在函数return前自动调用
      2、多个defer：遵循栈先进后出，跟析构函数一样，即先定义的后执行
      3、defer语句执行出错：不影响后面的defer语句执行
      4、defer语句中的传入的变量，其值等于执行到当前行时的变量值
```go

package main

import "fmt"

func main() {
	//testDefer()
	testDefer1()
}

//多个defer执行顺序：栈，先进后出，跟析构函数一样
func testDefer() {
	// 2222-> 3333 -> 8888->1111
	defer fmt.Println(1111)
	defer fmt.Println(8888)
	fmt.Println(2222)
	fmt.Println(3333)
	return
}

//defer定义时，如果传入了变量，则变量的值为执行到该行defer的值
func testDefer1() {
	//执行顺序： testErr(0) -> fmt.Println("END")
	i := 1
	defer fmt.Println(i)     // 1，不是等于100 defer语句中的变量值等于执行到当前行时的变量值
	defer fmt.Println("END") //还是会执行
	defer testErr(0)         //报错 integer divide by zero
	defer func(){
		fmt.Println(i)//100
	}()
	i = 100
	fmt.Println(i)
}

func testErr(a int) int {
	return 1 / a
}
```        

## 9、闭包
> 函数里面返回匿名函数；一个函数和与其相关的引用环境组合而成的实体（有点类似PHP的static变量）
闭包里面用的变量会一直存在。匿名函数同样被称之为闭包。它们被允许调用定义在其它环境下的变量。
闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。
另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。闭包经常被用作包装函数：它们会预先定义好 1 个或多个参数以用于包装。

`闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量`
```go
package main //必须

import "fmt"

//函数的返回值是一个匿名函数，返回一个函数类型
func test02() func() int {
	var x int //没有初始化，值为0

	return func() int {
		x++
		return x * x
	}
}

func main() {

	//返回值为一个匿名函数，返回一个函数类型，通过f来调用返回的匿名函数，f来调用闭包函数
	//它不关心这些捕获了的变量和常量是否已经超出了作用域
	//所以只有闭包还在使用它，这些变量就还会存在。
	f := test02()
	fmt.Println(f()) //1
	fmt.Println(f()) //4
	fmt.Println(f()) //9
	fmt.Println(f()) //16
	fmt.Println(f()) //25

}

func test01() int {
	//函数被调用时，x才分配空间，才初始化为0
	var x int //没有初始化，值为0
	x++
	return x * x //函数调用完毕，x自动释放
}

func main01() {
	fmt.Println(test01())
	fmt.Println(test01())
	fmt.Println(test01())
	fmt.Println(test01())
}

```

## 常用的内置函数
  
     close()： 主要关闭channel
     len()：求string/map/array/slice/channel长度  
     new()：分配内存，主要用来分配值类型(int,struct)，返回一个指针类型
     make(): 分配内存，主要用来分配引用类型（map,slice,channel）    
     append(): 追加array/slice元素
     panic(): 错误处理 
     recover:  错误发生，恢复程序运行