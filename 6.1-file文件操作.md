# 6.1、文件操作

## 1、获取用户终端输入
使用`fmt`包的`Scan`、`Scanf`和`Scanln`以及`Sscan`函数。
标准输入：`os.Stdin` 
标准输出：`os.Stdout` 都是`*os.File`

        //从终端读取
        fmt.Scanf(format string, a ...interface{}) (n int, err error)：格式化输入，format决定如何读取数据，格式化格式与格式化输出一致，遇到换行符结束
        fmt.Scan(a ...interface{}) (n int, err error) ：从终端获取用户输入,以换行符和空格作为分隔符
        fmt.Scanln(a ...interface{}) (n int, err error) ： 从终端获取用户输入，以空格分割并依次放入到后续的参数内，碰到换行符结束
        
        //从字符串读取，规则和从终端获取一致
        fmt.Sscan()
        fmt.Sscanf()
        fmt.Sscanln()

       //使用 bufio包读取标准输入
       inputReader := bufio.NewReader(os.Stdin) //获取reader指针
       input,_ = inputReader.ReadString('\n') //input为读取的字符串，\n为换行符
       
       
```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

//读取标准输入输出
func main() {
	//1、读取标准输入
	//testScanf()
	//testScan()
	//testScanln()
	//testSscan()
	testBufioread()
}

//scanf决定输入的格式
func testScanf() {
	var (
		a int
		b string
		c float32
	)
	fmt.Scanf("%d %s %f", &a, &b, &c)
	fmt.Println(a, b, c)
}

//Scan以换行符和空格作为分隔符
func testScan() {
	var (
		a int
		b string
		c float32
	)
	fmt.Scan(&a, &b, &c)
	//fmt.Scan(&a)
	//fmt.Scan(&b)
	//fmt.Scan(&c)
	fmt.Println(a, b, c)
}

//一行输入，以空格作为分隔符
func testScanln() {
	var (
		a int
		b string
		c float32
	)
	fmt.Scanln(&a, &b, &c)
	fmt.Println(a, b, c)
}

func testSscan() {
	var (
		a int
		b string
		c float32
	)
	s := "1234 qwer 5.565"
	fmt.Sscan(s, &a, &b, &c)
	fmt.Println(a, b, c)
}

//使用bufio读取的字符串会包括分隔符
func testBufioread() {
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString('\n')
	if err != nil {
		return
	}
	fmt.Println(input)
}
```        

## 2、文件读取
>标准输入输出`os.Stdin`和`os.Stdout`都是`*os.File`类型，表示打开一个文件句柄

- a、打开文件 `os.Open(file string)`，返回`*os.File`
> 打开文件，要记得关闭 `defer fd.Close()`


- b、读取文件内容
> 读取文件可以使用`bufio`、`ioutil`或者`fmt.FScan`开头的函数;读取到文件末尾是，会返回`io.EOF`的`err`

        
          //1、使用bufio逐行读取（要先获取文件句柄 *os.File）
          fd,err := os.Open("文件路径")
          reader := bufio.NewReader(fd)
          for {
             line,readErr := reader.ReadString('\n')
          }
          
          //2、使用bufio循环读取（要先获取文件句柄）：读取二进制文件很有用
           fd,err := os.Open("文件路径")
           buf := make([]byte,1024)
           for {
            reader := bufio.NewReader(fd)
            input,readErr := reader.Read(buf)
           }
          
          //3、使用fmt.Fscan开头函数（要先获取文件句柄 *os.File）: 适合读取格式固定的文件
          fd,err := os.Open("文件路径")
          for {
             var s string
             fmt.Fscanln(fd, &s)  //以空格分割的行
             fmt.Fscan(&s) //以空格或换行符分割
             fmt.Fscanf
          }
           
          //4、使用ioutil包一次性读取成字符串
          content,err := ioutil.readFile("文件路径") 
          contents, _ := ioutil.ReadAll("*os.File类型指针")
          
          //5、使用(*os.File)的Read开头的方法循环读取
          fd.Read()
 
 - c、可以使用`compress`包读取压缩文件
```go
 package main
 
 import (
 	"fmt"
 	"bufio"
 	"os"
 	"compress/gzip"
 )
 
 func main() {
 	fName := "MyFile.gz"
 	var r *bufio.Reader
 	fi, err := os.Open(fName)
 	if err != nil {
 		fmt.Fprintf(os.Stderr, "%v, Can't open %s: error: %s\n", os.Args[0], fName,
 			err)
 		os.Exit(1)
 	}
 	defer fi.Close()
 	fz, err := gzip.NewReader(fi)
 	if err != nil {
 		r = bufio.NewReader(fi)
 	} else {
 		r = bufio.NewReader(fz)
 	}
 
 	for {
 		line, err := r.ReadString('\n')
 		if err != nil {
 			fmt.Println("Done reading file")
 			os.Exit(0)
 		}
 		fmt.Println(line)
 	}
 } 
``` 


 ## 3、文件写入
> 写文件都需要先获取文件句柄，即`*os.File`
- a、使用`*os.File`的方法如`WriteString`写入文件内容. <br>
> 可以使用`openFile(name string, flag int, perm FileMode)`打开文件，
`name`为文件名,`flag`为打开模式（`os.O_RDONLY:只读,os.O_WRONLY:只写,os.O_CREATE:文件不存在则创建,os.O_TRUNC：文件已存在，则将文件长度截为0`,多个参数使用`|`连接），
写文件时，`perm`必须为`0666`；
        
           fd,err := os.openFile("b.txt",os.O_WRONLY|os.CREATE,0666)//openFile打开文件
           fd,err := os.Create("文件名") //读写模式创建新文件，如果文件存在则会被置为空文件 os.Open()方法不行，因为是只读模式   
           defer fd.Close()        
           fd.WriteString("text")   
           
           //flag参数详解
           os.O_RDWR  : 读写模式打开
           os.O_RDONLY: 只读模式  
           os.O_WRONLY: 只写模式  
           os.O_CREATE: 文件不存在则创建  
           os.O_TRUNC:  文件存在则将文件长度截断为0 
           os.SYNC  :  打开文件用于同步I/O
           os.O_APPEND : 追加模式
           
           
           
- b、使用`bufio`带缓冲写入文件内容（如`bufio.NewWriter(fd).WriteString(string)`）
> `bufio`包都需要先获取文件句柄`*os.File`，再转换成`bufio`包的`writer`写入缓冲区;写入之后需要调用`flush`写入文件
               
          fd,err := openFile("file path",os.O_WRONLY|os.O_CREATE,0666)
          writer := bufio.NewWriter(fd)
          writer.WriteString("1")      
          writer.Flush()      

- c、使用`ioutil`包一次性写入
> `ioutil.WriteFile()`
     
        ioutil.WriteFile(文件名,字节数组,0666)

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

//使用*os.File的方法直接写入
func main() {
	fd, err := os.OpenFile("b.txt", os.O_CREATE|os.O_WRONLY, 0666)
	defer fd.Close()
	if err != nil {
		return
	}
	for i := 0; i < 10; i++ {
		_, _ = fd.WriteString(fmt.Sprintf("%d = %d\n", i, i))
	}
	testBufioWriter()
}

//bufio带缓冲写入，性能比直接写入强
func testBufioWriter() {
	fd, err := os.OpenFile("b1.txt", os.O_CREATE|os.O_WRONLY, 0666)
	defer fd.Close()
	if err != nil {
		return
	}
	writer := bufio.NewWriter(fd)
	for i := 0; i < 10; i++ {
		_, _ = writer.WriteString(fmt.Sprintf("%d = %d\n", i, i))
	}
	writer.Flush() //必须调用该函数，否则不会写入文件
}

func TestIoutilWriteFile() error {
	return ioutil.WriteFile("b1.txt", []byte("123123131"), 0666)
}
```

## 4、拷贝文件
>使用`os.Copy`方法实现
 
```go

package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	CopyFile("target.txt", "source.txt")
	fmt.Println("Copy done!")
}

func CopyFile(dstName, srcName string) (written int64, err error) {
	src, err := os.Open(srcName)
	if err != nil {
		return
	}
	defer src.Close()

	dst, err := os.Create(dstName)
	if err != nil {
		return
	}
	defer dst.Close()

	return io.Copy(dst, src)
}
```    
## 注意事项
- a、`os.Open`是只读模式`os.O_RDONLY`，`os.Create`创建文件，是`os.O_RDWR`读写模式(如果文件已存在会截断它,即空文件)；`os.openFile`可以选择打开文件模式
- b、`ioutil`包可以使用`ReadFile`和`WriteFile`一次性读取和写入文件，非常方便；`bufio`为带缓冲的io操作，使用`NewReader`和`NewWrite`也可以读取和写入文件；`*os.File`自带的写入文件函数














                                      