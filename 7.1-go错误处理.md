# 7.1 错误处理

## 1、`error`错误接口使用
>返回一个错误对象方式：<br>



`errors.New(msg string)`：使用内置`errors`包<br>
`fmt.Errorf(fmt string,v interface{}...)`：fmt的Errorf方法



```go

package main

import (
	"errors"
	"fmt"
)

func main() {

	//1、errors.New() 返回 *errors.errorString对象
	err := errors.New("Error")
	fmt.Println(err)
	fmt.Printf("%t,%T\n", err, err)

	//2、fmt.Errorf 返回 *errors.errorString对象
	err1 := fmt.Errorf("%s%d", "Error:", 1)
	fmt.Println(err1)
	fmt.Printf("%t,%T", err1, err1)

}
```

## 2、运行时异常`panic`
> `panic( a interface{})`会直接使程序退出，如果`panic`之前定义有`defer`语句，则`defer`语句会在输出错误信息之前调用每一层的`defer`语句
```go

package main

import "fmt"

func main() {
	t1()
	t2()
	t3()

}

func t1() {
	fmt.Println("t1")
}

func t2() {
	defer func() {
		fmt.Println("defer")
	}()
	panic("t2")
}

func t3() {
	fmt.Println("t3")
}

```

## 3、从`panic`恢复程序执行`recover`
> 当程序`panic`后是可以从崩溃出恢复执行的，使用`recover()`函数实现，`recover只能在defer语句修饰的函数使用`<br>.
当程序正常执行时，`recover()`函数返回`nil`，产生`panic`时则不为空。`panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止`


       defer-panic-recover
       
       //必须在defer修饰的函数中使用
       if err := recover();err != nil {
          //todo 错误处理
       }

```go
var arr [5]int

func testReceover(i int) {
	//recover只能在defer语句修饰的函数使用
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
		}
	}()
	fmt.Println(arr[i]) //数组越界会panic  panic: runtime error: index out of range
}
func main(){
	testReceover(5) //runtime error: index out of range
}
```
可以通过使用闭包来减少`recover`代码调用
```go

package main
import "fmt"
func main(){
	
}

type funcType func(int)int 

func returnClosure(f1 funcType)(f funcType){
	
	return func( int ) int {
		defer func(){
			if err:= recover();err != nil {
				fmt.Println(err)
			}
		}()
		return 0
	}
}
```
 
 ## 4、启动外部程序或命令
 > `os.StartProcess()` 和 `exec`包`command`

 