# 8.2 管道`channel`
> 协程之间可以通过全局变量来通信，但不推荐，推荐使用`channel`管道。
  数据在通道中进行传递：在任何给定时间，一个数据被设计为只有一个协程可以对其访问，所以不会发生数据竞争。
  数据的所有权（可以读写数据的能力）也因此被传递。可以理解为队列，消息先进先出。类似unix系统的pipe管道。

## 1、管道定义（使用`channel`）
> 使用`chan`关键字来声明。只能传递一种数据类型。
 
        //声明一个管道
        var identifier chan datatype //  datatype为数据类型，未初始化的管道的值为nil
        var ch chan int //例子 等于nil
        
        ch := make(chan datatype, len) //使用make关键字定义，分配内存
        

## 2、通信操作符 `<-`    
> 既可以发送也可以接收，有3种方式 
        
         ch := make(chan int) //chan为管道
         ch <- data ： 表示发送数据到管道
         d <-ch ：表示从管道取出数据
         <- ch ：单独调用获取通道的下一个值，但不接受
                   
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int)
	go sendData(ch)
	go getData(ch)
	time.Sleep(time.Second)
}

//向通道发送消息 <-
func sendData(ch chan int) {
	for i := 0; i < 10; i++ {
		ch <- i //发送数据
	}
}

func getData(ch chan int) {
	for {
		fmt.Println("GETDATA")
		data := <-ch
		fmt.Println(data)
	}
}
``` 
       
## 3、阻塞管道
> 使用`make`创建管道时，若没指明长度则为阻塞管道，默认为阻塞管道；否则为有缓冲的通道。<br>
无缓冲（阻塞）管道：`发送者和接收者必须都准备好，只要其中一方没准备好，则通道是阻塞的。`      

       1、对同一个通道，发送操作在接收者准备好之前是阻塞的。发送和接收操作在对方准备好之前，通道是阻塞的。
       2、对同一个通道，当通道中没有数据时，接收者是阻塞的
           
```go
package main

import "fmt"

func main() {
	ch1 := make(chan int)
	go pump(ch1)       // pump hangs
	fmt.Println(<-ch1) // 只输出0
}

func pump(ch chan int) {
	for i := 0; ; i++ {
		ch <- i //发送数据，在接收者准备好之前是阻塞的
	}
}

//################### 下面👇会造成死锁
func f1(in chan int) {
	fmt.Println(<-in)
}

func main() {
	out := make(chan int)
	out <- 2 //发送者在接收者准备好之前是阻塞的，后面的代码都不会执行
	go f1(out)
}
```

## 4、缓冲通道
> 使用 `make`函数声明带缓冲的通道，如 `ch:=make(chan int,1)`；<br>
`缓冲通道发送数据，在缓冲使用完之前是异步非阻塞的，使用完后则变成阻塞；从缓冲通道读取数据也不会阻塞，直到数据为空`；阻塞通道可以理解为`make(chan datatype,0)`


        //定义缓冲通道
        ch := make(chan datatype, size) //size为缓冲容量，size等于0时为阻塞通道
        
        //常用函数
        len(ch) : 通道中剩余数据个数，阻塞通道为0
        cap(ch) : 通道的容量，阻塞通道为0
        

## 5、信号量同步(如token-buffer机制)
> 信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 sync 的 Go 包，使用带缓冲的通道可以轻松实现：

## 6、`for-range`通道遍历
> `for-range`可以遍历通道，从通道中获取数据直到通道关闭（程序退出也会关闭通道），否则会一直阻塞。

 ```go
package main

import (
	"fmt"
)
//整个程序会阻塞
func main() {
	suck(pump())
	//time.Sleep(1e9) //主协程退出，子协程也退出
	for {
		;
	}
}

func pump() chan int {
	ch := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
	}()
	return ch
}

func suck(ch chan int) {
	go func() {
		for v := range ch {
			fmt.Println(v)
		}
	}()
}


```   
## 7、通道方向（只写，只读）
>通道是可以有方向的，只读通道无法关闭`Close(ch)`，因为关闭通道的做法是，告诉发送者不能再给通道发送数据，只读通道无法写入数据。`双向通道可以作为单方向通道使用`
        
         var send_only chan<- int  //指向通道，只写
         var read_only  <-chan int // 通道输出，只读
         
## 8、`select`切换协程(监听channel数据的流动)         
> `select`通信开关，类似`switch`用法，轮询通道，一般配合循环来使用。`select`可以监听数据进入，也可以用在通道发送值的时候。
`default`语句可选。`case`中使用`break`可以退出`select`，如果用了循环则不会退出外层循环。

> `select`语句：根据`case`语句判断执行，可能会阻塞；选择处理列出的多个通信情况中的一个
- 如果都阻塞了，会等待直到其中一个可以处理
- 如果多个可以处理，随机选择一个
- 如果没有通道操作可以处理并且写了 `default` 语句，它就会执行：`default 永远是可运行的`（这就是准备好了，可以执行）。
在 select 中使用发送操作并且有 default 可以确保发送不被阻塞！如果没有 default，select 就会一直阻塞

## 9、`timer`定时器使用

        tk := time.NewTicker(time.Second) //返回 *Ticker，使用Stop停止定时器
        tk := time.Tick(duration) //返回通道，定时发送时间
        tk := time.After(duration) //返回通道，只发送一次时间
         
## 10、通道的实际应用
- a、信号量模式：将通道当成信号量
- b、`Token-buffer`模式限流：使用有缓冲的通道实现；php可以使用redis实现
- c、并发安全访问对象：在对象中定义一个通道，开启一个协程遍历通道中的数据，通道中访问数据是原子性的，所以可以做到安全访问对象。
```go
package main

import (
	"fmt"
	"strconv"
)

type Person struct {
	Name   string
	salary float64
	chF    chan func()
}

func NewPerson(name string, salary float64) *Person {
	p := &Person{name, salary, make(chan func())}
	go p.backend()
	return p
}

func (p *Person) backend() {
	for f := range p.chF {
		f()
	}
}

// Set salary.
func (p *Person) SetSalary(sal float64) {
	p.chF <- func() { p.salary = sal }
}

// Retrieve salary.
func (p *Person) Salary() float64 {
	fChan := make(chan float64)
	p.chF <- func() { fChan <- p.salary }
	return <-fChan
}

func (p *Person) String() string {
	return "Person - name is: " + p.Name + " - salary is: " + strconv.FormatFloat(p.Salary(), 'f', 2, 64)
}

func main() {
	bs := NewPerson("Smith Bill", 2500.5)
	fmt.Println(bs)
	bs.SetSalary(4000.25)
	fmt.Println("Salary changed:")
	fmt.Println(bs)
}
```     
   
## 注意事项
- a、发送者和接收者必须都存在，否则会形成死锁。发送者和接收者声明的顺序可以不确定。
- b、阻塞通道发送数据在接收者准备好之前是阻塞的，接收者在通道无数据的情况读取是阻塞的。
- c、缓冲通道发送数据在使用完缓冲之前是异步非阻塞，使用完之后为阻塞；接收者在通道无数据的情况读取是阻塞的。

     