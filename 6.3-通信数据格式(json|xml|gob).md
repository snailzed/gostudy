# 6.3 通信数据格式

## 1、JSON
> go一般是使用`encoding/json`包实现JSON的编码和解码.可以将json字符串解码为`struct结构体`、`map字典`等等

           
             json.Marshal(v interface{}) ([]byte, error) //json编码
             json.Unmarshal(data []byte, v interface{}) error //json解码  v需要传入一个指针      
         
```go
package main

import (
	"encoding/json"
	"fmt"
)

type Msg struct {
	Code    int         `json:"code"`
	Message string      `json:"msg"`
	Data    interface{} `json:"data"`
}

func main() {
	msg := Msg{Code: 0, Message: "Hello", Data: 1}
	m, err := json.Marshal(msg)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(m, string(m))

	var map1 map[string]interface{}
	err = json.Unmarshal(m, &map1)
	fmt.Println(map1)

	var m2 Msg
	err = json.Unmarshal(m, &m2)
	fmt.Println(m2)
}

```         

## 2、`xml`格式
> `encoding/xml`可以从文件读取或者写入     

    xml.Unmarshal() //将xml文件解析成结构体
    xml.Marshal()   //将结构体设置为xml文件  
```go
package main

import (
	"encoding/xml"
	"fmt"
	"strings"
)

var t, token xml.Token
var err error

func main() {
	input := "<Person><FirstName>Laura</FirstName><LastName>Lynn</LastName></Person>"
	inputReader := strings.NewReader(input)
	p := xml.NewDecoder(inputReader)

	for t, err = p.Token(); err == nil; t, err = p.Token() {
		switch token := t.(type) {
		case xml.StartElement:
			name := token.Name.Local
			fmt.Printf("Token name: %s\n", name)
			for _, attr := range token.Attr {
				attrName := attr.Name.Local
				attrValue := attr.Value
				fmt.Printf("An attribute is: %s %s\n", attrName, attrValue)
				// ...
			}
		case xml.EndElement:
			fmt.Println("End of token")
		case xml.CharData:
			content := string([]byte(token))
			fmt.Printf("This is the content: %v\n", content)
			// ...
		default:
			// ...
		}
	}
}

/**
输出：

Token name: Person
Token name: FirstName
This is the content: Laura
End of token
Token name: LastName
This is the content: Lynn
End of token
End of token
 */
``` 
          
## 3、`Gob`格式             
> Gob（Go binary） 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；只能go语言中使用。高效且简单。使用`econding/gob`进行编码和解码。文件中gob格式是二进制和文本的混合模式。
`只有可导出的字段才会编码，默认值也会忽略；解析为结构体时，必须要匹配名称和可兼容类型才会被解析成功`

           gob.NewEncoder(w io.Writer) *Encoder //返回一个encoder
           gob.NewDecoder(r io.Reader) *Decoder //返回一个reader
           (enc *Encoder) Encode(e interface{}) error //编码
           (dec *Decoder) Decode(e interface{}) error //解码，必须传入指针类型

>编码：使用`NewEncoder`获取`*Encoder`，再使用`Encoder`调用`Encode`方法编码；<br>
解码：使用`NewDecoder`获取`*Decoder`，再使用`*Decoder`调用`Decode`方法解码



           
           
             
   