# GoLANG性能优化

## 1、常见的优化方法
> 优化分前端优化和后端优化


前端优化方法：
- 1、减少HTTP请求数，合并JS、CSS和图片
- 2、CDN缓存，实现就近访问


后端优化方法：

- 1、web服务器启用`gzip`压缩，减少数据体积
- 2、使用缓存，如redis、memcache、mongodb等，提高响应速度
- 3、优化SQL


## 2、CPU性能分析
> 火焰图；go语言中可以使用`ruetime/pprof`包来分析性能，包括CPU、MEM和锁。`pprof`开启后，每隔一段时间（10ms）
会收集当前的堆栈信息，获取每个函数占用的CPU以及MEM；当`pprof`采集数据完成之后，会对这些数据进行分析，形成一个分析报告。


      采集数据：
         1、import("runtime/pprof")
         2、开始CPU性能分析： pprof.StartCPUProfile(w io.Writer)
         3、停止CPU性能分析： pprof.StopCPUProfile()
 
 
       
       数据分析：
         1、生成数据之后，可以使用 【go tool pprof 编译后的程序  生成的采集数据文件】（go tool pprof ./codeAnalysis ./analysis.pprof ）
         2、列含义：
            flat：当前函数占用CPU时间
            flat%： 当前函数占用CPU时间百分比
            sum%：函数消耗的CPU耗时的累计占比
            cum：当前函数加上调用当前函数的函数消耗的CPU时间
            cum%：消耗的CPU总百分比
            
         3、topN：列举消耗CPU排名前N个的函数   
         4、list 函数名：可以查看函数消耗的CPU时间
       

```go
package main

import (
	"fmt"
	"os"
	"runtime/pprof"
	"time"
)

func Test() {
	ch := make(chan int, 1)
	for {
		select {
		case ret := <-ch:
			fmt.Println(ret)
		default:
		}
	}
}
func main() {
	fd, err := os.Create("./analysis.pprof")
	if err != nil {
		panic(err)
	}
	err = pprof.StartCPUProfile(fd)
	if err != nil {
		panic(err)
	}
	defer pprof.StopCPUProfile()
	for i := 0; i < 8; i++ {
		go Test()
	}
	time.Sleep(10 * time.Second)
}

```
```
File: codeAnalysis
Type: cpu
Time: Sep 7, 2019 at 10:41am (CST)
Duration: 10.14s, Total samples = 58.94s (581.35%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) top3
Showing nodes accounting for 50.90s, 86.36% of 58.94s total
Dropped 15 nodes (cum <= 0.29s)
Showing top 3 nodes out of 4
      flat  flat%   sum%        cum   cum%
    23.52s 39.90% 39.90%     25.47s 43.21%  runtime.chanrecv
    18.68s 31.69% 71.60%     50.16s 85.10%  runtime.selectnbrecv
     8.70s 14.76% 86.36%     58.86s 99.86%  main.test
```   
 
 ## 3、内存分析
 
        
        采集数据：
          1、import("runtime/pprof")
          2、pprof.WriteHeapProfile(w io.Writer)
          3、使用 go tool pprof进行分析
              默认使用--inuser_space（内存分配大小）进行统计，可以使用--inuse-objects查看分配的数量
          4、topN：列举消耗CPU排名前N个的函数   
          5、list 函数名：可以查看函数消耗的CPU时间
                     
 
 
 ## 4、性能分析与压力测试结合
 
 
        步骤：
         1、先编写Benchmark压力测试函数
         2、使用 go test -c 生成可执行程序[XXXXX.test]
         3、分析CPU性能：
             ./xxxx.test -test.bench=压力测试函数名 -test.cpuprofile=./cpu.pprof
         4、分析内存：
             ./xxxx.test -test.bench=压力测试函数名 -test.memprofile=./mem.pprof
         5、go tool pprof 可执行程序 pprof文件
      

## 5、火焰图分析
> 将生成的pprof数据转化成火焰图来分析。

          步骤：
             1、安装uber工具
                 go get github.com/uber/go-torch
                 
             2、安装FlameGraph 
               git clone https://github.com/brendangregg/FlameGraph.git
                
             3、将FlameGraph安装目录添加到PATH路径
               export PATH="${PATH}:path-to-flamegraph"
               
             4、执行 [go-toch 可执行程序  pprof文件] 进行分析    
                
## 6、原生HTTP和tcp相关后台程序
> 这种web服务型的程序，可以通过导入`net/http/pprof`包来分析性能

          步骤：
           1、导入包  import _ "net/http/pprof"
           2、查看信息：
               http://localhost:xxx/debug/pprof   
               
                  /debug/pprof/profile: 自动进行CPU pprof，并把分析数据下载
                  /debug/pprof/heap: 自动进行MEM pprof，并把分析数据下载
                  /debug/pprof/goroutines : 打印goroutine信息
                  /debug/pprof/goroutines : 打印goroutine信息
                  

           如要分析gin框架的性能，可以导入 go get github.com/DeanThompson/ginpprof    
           
           
           import (
             "github.com/DeanThompson/ginpprof"
           )                         
          
           ginpprof.Wrap(router)