# 10.8 协程和通道使用注意事项

- 当且仅当代码中并发执行非常重要，才使用协程和通道
- 闭包和协程使用：
      
```go
package main

import (
    "fmt"
    "time"
)

var values = [5]int{10, 11, 12, 13, 14}

func main() {
    // 版本A:
    for ix := range values { // ix是索引值
        func() {
            fmt.Print(ix, " ")
        }() // 调用闭包打印每个索引值
    }
    fmt.Println()
    // 版本B: 和A版本类似，但是通过调用闭包作为一个协程
    for ix := range values {
        go func() {
            fmt.Print(ix, " ")
        }()
    }
    fmt.Println()
    time.Sleep(5e9)
    // 版本C: 正确的处理方式
    for ix := range values {
        go func(ix interface{}) {
            fmt.Print(ix, " ")
        }(ix)
    }
    fmt.Println()
    time.Sleep(5e9)
    // 版本D: 输出值:
    for ix := range values {
        val := values[ix]
        go func() {
            fmt.Print(val, " ")
        }()
    }
    time.Sleep(1e9)
}
```  
     输出：
     
     0 1 2 3 4
     
     4 4 4 4 4
     
     1 0 3 4 2
     
     10 11 12 13 14    
      

A版本肯定是没错，循环体里面使用了同步的匿名函数，结果无异议。<br/>
B版本循环体中使用了协程和闭包，闭包是可以捕获外部变量的，在这里是捕获同一个变量，当循环完毕时，协程可能还没执行，所以结果是 `4 4 4 4 4 4`。<br/>
C版本闭包使用，传入的值与当前执行的值一致，无异议。<br/>
D版本是作用域问题，`{}`里面的变量都是不一样的，都是独立的一份，每隔闭包用的都是属于自己的变量。      