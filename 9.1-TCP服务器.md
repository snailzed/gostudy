# 9.1 `TCP`服务器
> 需要使用`net`包，关键函数解析：<br>

## 1、创建tcp服务器
       net.Listen(network, address string) (Listener, error): 监听一个地址，network只能为`"tcp", "tcp4", "tcp6", "unix" or "unixpacket"`，address为`ip:端口`
       listen.Accept (Conn, error): 服务器d端接受连接      
       net.Dial(network, address string) (Conn, error): 创建一个socket连接，连接指定地址
       net.ResolveIPAddr(network, address string) (*IPAddr, error)： 解析主机地址
      
       
       
       //net.Conn连接方法
       conn.Write([]byte) :往socket连接写入数据
       conn.Read([]byte)  :读取socket中的数据
       conn.Close() : 短连接需要关闭
```go
package main

import (
	"fmt"
	"io"
	"net"
	"strings"
)

func main() {

	fmt.Println("Start to create tcp server...")
	//监听地址
	listerner, err := net.Listen("tcp", "127.0.0.1:8080")
	if err != nil {
		fmt.Println("start server error:", err)
		return
	}
	// 监听并接受来自客户端的连接
	for {
		conn, err := listerner.Accept()//没有连接会阻塞
		if err != nil {
			fmt.Println("Accept connection error:", err)
		}
		go acceptConn(conn)
	}
}

func acceptConn(conn net.Conn) {
	buf := make([]byte, 1024)
	for {
		n, err := conn.Read(buf)
		if err != nil {
			if err == io.EOF {
				fmt.Println("connetion closed.")
				return
			}
			fmt.Println("read data from conn error:", err)
			return
		}
		fmt.Println("read data from conn:", string(buf[:n])) //读取多少字节则输出多少字节
		//发回客户端
		str := strings.ToUpper(string(buf[:n]))
		_, err = conn.Write([]byte(str))
	}
}

```    

## 2、`net`包的错误
> 通常是返回`error`，有些包还包含了额外的方法，实现了`net.Error`
  
        package net
        
        type Error interface {
        	Timeout() bool // 错误是否超时
        	Temporary() bool // 是否是临时错误
        }
 
      // in a loop - some function returns an error err
    if nerr, ok := err.(net.Error); ok && nerr.Temporary() {
   	  time.Sleep(1e9)
   	  continue // try again
    }
    if err != nil {
   	 log.Fatal(err)
    }    